{
  "files": {
    "src/index.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "0",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "dateFunction is not a function",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 17
            },
            "start": {
              "column": 42,
              "line": 15
            }
          }
        },
        {
          "id": "1",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "Cannot read properties of undefined (reading 'toISOString')",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0"
          ],
          "location": {
            "end": {
              "column": 34,
              "line": 16
            },
            "start": {
              "column": 12,
              "line": 16
            }
          }
        },
        {
          "id": "2",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected '2025-05-19T11:32:49.702Z : I am a log…' to be '2023-09-06T00:00:00.000Z : I am a log…' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 27
            },
            "start": {
              "column": 62,
              "line": 25
            }
          }
        },
        {
          "id": "3",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "Cannot read properties of undefined (reading 'toISOString')",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0"
          ],
          "location": {
            "end": {
              "column": 44,
              "line": 26
            },
            "start": {
              "column": 12,
              "line": 26
            }
          }
        },
        {
          "id": "4",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 50,
              "line": 34
            },
            "start": {
              "column": 24,
              "line": 34
            }
          }
        },
        {
          "id": "5",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected 'Error: TypeError: fetch failed' to be 'User John Doe' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 66
            },
            "start": {
              "column": 18,
              "line": 63
            }
          }
        },
        {
          "id": "6",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "expected 'Error: TypeError: Cannot read propert…' to be 'User John Doe' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1"
          ],
          "location": {
            "end": {
              "column": 54,
              "line": 65
            },
            "start": {
              "column": 12,
              "line": 64
            }
          }
        },
        {
          "id": "7",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 73
            },
            "start": {
              "column": 71,
              "line": 71
            }
          }
        },
        {
          "id": "8",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 20,
              "line": 80
            },
            "start": {
              "column": 5,
              "line": 80
            }
          }
        },
        {
          "id": "9",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 88
            },
            "start": {
              "column": 80,
              "line": 86
            }
          }
        },
        {
          "id": "10",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 46,
              "line": 94
            },
            "start": {
              "column": 5,
              "line": 94
            }
          }
        },
        {
          "id": "11",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 98
            },
            "start": {
              "column": 5,
              "line": 95
            }
          }
        },
        {
          "id": "12",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 56,
              "line": 96
            },
            "start": {
              "column": 18,
              "line": 96
            }
          }
        },
        {
          "id": "13",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 54,
              "line": 96
            },
            "start": {
              "column": 36,
              "line": 96
            }
          }
        },
        {
          "id": "14",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 109
            },
            "start": {
              "column": 43,
              "line": 106
            }
          }
        },
        {
          "id": "15",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 59,
              "line": 107
            },
            "start": {
              "column": 18,
              "line": 107
            }
          }
        },
        {
          "id": "16",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 57,
              "line": 107
            },
            "start": {
              "column": 36,
              "line": 107
            }
          }
        },
        {
          "id": "17",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 7,
              "line": 117
            },
            "start": {
              "column": 45,
              "line": 114
            }
          }
        },
        {
          "id": "18",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "Test timed out in 5000ms.\nIf this is a long-running test, pass a timeout value as the last argument or configure it globally with \"testTimeout\".",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 117
            },
            "start": {
              "column": 33,
              "line": 115
            }
          }
        },
        {
          "id": "19",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "expected 'Error: Error' to be 'Error: Error: Connection failed ETIME…' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1"
          ],
          "location": {
            "end": {
              "column": 54,
              "line": 116
            },
            "start": {
              "column": 25,
              "line": 116
            }
          }
        },
        {
          "id": "20",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 174,
              "line": 123
            },
            "start": {
              "column": 5,
              "line": 123
            }
          }
        },
        {
          "id": "21",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 127
            },
            "start": {
              "column": 5,
              "line": 124
            }
          }
        },
        {
          "id": "22",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 56,
              "line": 125
            },
            "start": {
              "column": 18,
              "line": 125
            }
          }
        },
        {
          "id": "23",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 54,
              "line": 125
            },
            "start": {
              "column": 36,
              "line": 125
            }
          }
        },
        {
          "id": "24",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 76,
              "line": 134
            },
            "start": {
              "column": 5,
              "line": 134
            }
          }
        },
        {
          "id": "25",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 20,
              "line": 135
            },
            "start": {
              "column": 5,
              "line": 135
            }
          }
        },
        {
          "id": "26",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 49,
              "line": 142
            },
            "start": {
              "column": 5,
              "line": 142
            }
          }
        },
        {
          "id": "27",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 52,
              "line": 143
            },
            "start": {
              "column": 9,
              "line": 143
            }
          }
        },
        {
          "id": "28",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 20,
              "line": 144
            },
            "start": {
              "column": 5,
              "line": 144
            }
          }
        },
        {
          "id": "29",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 39,
              "line": 151
            },
            "start": {
              "column": 5,
              "line": 151
            }
          }
        },
        {
          "id": "30",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 20,
              "line": 152
            },
            "start": {
              "column": 5,
              "line": 152
            }
          }
        },
        {
          "id": "31",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "2"
          ],
          "coveredBy": [
            "2"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 173
            },
            "start": {
              "column": 66,
              "line": 171
            }
          }
        },
        {
          "id": "32",
          "mutatorName": "StringLiteral",
          "replacement": "``",
          "statusReason": "expected [Function] to throw error including 'Exit function was called with code 1' but got ''",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "2"
          ],
          "coveredBy": [
            "2"
          ],
          "location": {
            "end": {
              "column": 65,
              "line": 172
            },
            "start": {
              "column": 21,
              "line": 172
            }
          }
        },
        {
          "id": "33",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "Static mutant (and \"ignoreStatic\" was enabled)",
          "status": "Ignored",
          "static": true,
          "coveredBy": [],
          "location": {
            "end": {
              "column": 67,
              "line": 196
            },
            "start": {
              "column": 52,
              "line": 196
            }
          }
        }
      ],
      "source": "/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\n// Date related types and functions\r\n\r\n/**\r\n * Type for a function that returns a Date.\r\n */\r\ntype DateFunction = () => Date\r\n\r\n/**\r\n * Returns a DateFunction that returns the current date.\r\n * Can for example be used to get the current date when logging.\r\n * @returns DateFunction function returning the current data\r\n */\r\nfunction nowDateFunction(): DateFunction {\r\n    return (): Date => new Date()\r\n}\r\n\r\n/**\r\n * Returns a DateFunction that returns a fixed date.\r\n * Can for example be used to get a fixed date for testing.\r\n * @param dateString fixed date string\r\n * @returns DateFunction function returning the fixed date\r\n */\r\nfunction fixedDateFunction(dateString: string): DateFunction {\r\n    return (): Date => new Date(dateString)\r\n}\r\n\r\n/**\r\n * Test date\r\n * '1001-01-01T00:00:00.000Z'\r\n * as ISO Date string. Can be used to ease and unify testing.\r\n */\r\nconst testDateString = '1001-01-01T00:00:00.000Z'\r\n\r\n/**\r\n * DateFunction that returns the test date.\r\n * Can for example be used to always get the date when testing.\r\n */\r\nconst testDateFunction: DateFunction = fixedDateFunction(testDateString)\r\n\r\n// Fetch related types and functions\r\n\r\n/**\r\n * Type for a fetch function that given an input (url, request, etc.) and request init\r\n * returns a Promise<Response>\r\n */\r\ntype FetchFunction = (\r\n    input: string | URL | Request,\r\n    init?: RequestInit,\r\n) => Promise<Response>\r\n\r\n/**\r\n * Returns a FetchFunction that always returns a fixed response.\r\n * Can for example be used to get a fixed Response for testing.\r\n * @param bodyInit body for the response\r\n * @param init response init\r\n * @returns FetchFunction function returning the fixed Response\r\n */\r\nfunction fixedResponseFetchFunction(\r\n    bodyInit?: BodyInit,\r\n    init?: ResponseInit,\r\n): FetchFunction {\r\n    return (): Promise<Response> =>\r\n        Promise.resolve(new Response(bodyInit, init))\r\n}\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with and empty body and status 400 (Bad Request).\r\n */\r\nconst badRequestFetchFunction = fixedResponseFetchFunction(undefined, {\r\n    status: 400,\r\n})\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with and empty body and status 404 (Not Found).\r\n */\r\nconst notFoundFetchFunction: FetchFunction = fixedResponseFetchFunction(\r\n    undefined,\r\n    { status: 404 },\r\n)\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with and empty body and status 500 (Internal Server Error).\r\n */\r\nconst internalServerErrorFetchFunction = fixedResponseFetchFunction(undefined, {\r\n    status: 500,\r\n})\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with broken JSON (missing bracket)\r\n */\r\nconst brokenJSONFetchFunction: FetchFunction = fixedResponseFetchFunction(\r\n    '{\"data\": {\"message\": \"Missing bracket\"}',\r\n    {\r\n        headers: { 'Content-Type': 'application/json' },\r\n        status: 200,\r\n    },\r\n)\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with an unknown\r\n * Content-Type ('application/unknown')\r\n */\r\nconst unknownContentTypeFetchFunction: FetchFunction =\r\n    fixedResponseFetchFunction(undefined, {\r\n        headers: { 'Content-Type': 'application/unknown' },\r\n        status: 200,\r\n    })\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response that throws a Timeout error.\r\n */\r\nconst timeoutFetchFunction: FetchFunction = (): Promise<Response> =>\r\n    new Promise<Response>(() => {\r\n        throw new Error('Connection failed ETIMEDOUT')\r\n    })\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with an AggregateError.\r\n */\r\nconst aggregateErrorFetchFunction = fixedResponseFetchFunction(\r\n    '{\"errors\":[{\"message\":\"aaa The first error!, The second error!\", \"originalError\": {\"errors\": [{\"message\":\"The first error!\"}, {\"message\":\"The second error!\"}  ] }  }]}',\r\n    {\r\n        headers: { 'Content-Type': 'application/json' },\r\n        status: 200,\r\n    },\r\n)\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response that GraphQL introspection is disabled.\r\n */\r\nconst graphQLIntrospectionDisabledFetchFunction = fixedResponseFetchFunction(\r\n    '{\"errors\": [ { \"message\": \"Introspection is disabled\"}],\"data\": null}',\r\n    { status: 200 },\r\n)\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with an invalid GraphQL schema.\r\n */\r\nconst graphQLInvalidSchemaFetchFunction = fixedResponseFetchFunction(\r\n    '{\"data\": {\"__schema\":\"NotAGraphQLSchema\", ' +\r\n        '\"_service\": {\"sdl\":\"NotAGraphQLSchema\"}}}',\r\n    { status: 200 },\r\n)\r\n\r\n/**\r\n * FetchFunction that returns a fixed Response with an invalid GraphQL body.\r\n */\r\nconst graphQLInvalidBodyFetchFunction = fixedResponseFetchFunction(\r\n    '{\"message\": \"I am not GraphQL!\"}',\r\n    { status: 200 },\r\n)\r\n\r\n// Exit function related types and functions\r\n\r\n/**\r\n * Type for a function that given an exit does not return anything.\r\n * @param {number} code The exit code to use\r\n * @returns {never} Does not return anything, may e.g. exit the process or throw an error\r\n */\r\ntype ExitFunction = (code: number) => never\r\n\r\n/**\r\n * Exit function that does not exit the process but throws an error instead\r\n * Can be used in testing to avoid the tests exiting the application.\r\n * @param {number} code The exit code to be thrown in the error\r\n * @returns {never} Does not return anything but throws an error with the message\r\n * \"Exit function was called with code CODE\" where CODE is the given code.\r\n */\r\nconst doNotExitFunction: ExitFunction = (code: number): never => {\r\n    throw new Error(`Exit function was called with code ${code}`)\r\n}\r\n\r\n// Timeout function related types and functions\r\n\r\n/**\r\n * Type for a function that given a TimerHandler, optional timeout and arguments returns the timeout ID as number.\r\n * @param {TimerHandler} handler The TimerHandler to be called (i.e. in most cases a callback function)\r\n * @param {number} timeout The timeout in milliseconds\r\n * @param {any[]} timeoutArguments The arguments to be passed to the handler\r\n * @returns {number} The timeout ID as number\r\n */\r\ntype TimeoutFunction = (\r\n    handler: TimerHandler,\r\n    timeout?: number,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    ...timeoutArguments: any[]\r\n) => number\r\n\r\n/**\r\n * TimeoutFunction that does not call the callback function but returns a fixed timeout ID 1.\r\n * Can be used in testing to avoid the tests waiting for the timeout to finish.\r\n * @returns {number} Fixed timeout ID 1\r\n */\r\nconst noCallbackTimeoutFunction: TimeoutFunction = (): number => 1\r\n\r\nexport {\r\n    aggregateErrorFetchFunction,\r\n    badRequestFetchFunction,\r\n    brokenJSONFetchFunction,\r\n    doNotExitFunction,\r\n    fixedDateFunction,\r\n    fixedResponseFetchFunction,\r\n    graphQLIntrospectionDisabledFetchFunction,\r\n    graphQLInvalidBodyFetchFunction,\r\n    graphQLInvalidSchemaFetchFunction,\r\n    internalServerErrorFetchFunction,\r\n    noCallbackTimeoutFunction,\r\n    notFoundFetchFunction,\r\n    nowDateFunction,\r\n    testDateFunction,\r\n    testDateString,\r\n    timeoutFetchFunction,\r\n    unknownContentTypeFetchFunction,\r\n}\r\n\r\nexport type { DateFunction, ExitFunction, FetchFunction, TimeoutFunction }\r\n"
    }
  },
  "schemaVersion": "1.0",
  "thresholds": {
    "high": 80,
    "low": 60,
    "break": null
  },
  "testFiles": {
    "tests/index.test.ts": {
      "tests": [
        {
          "id": "0",
          "name": "Test date functions"
        },
        {
          "id": "1",
          "name": "Test fetch functions"
        },
        {
          "id": "2",
          "name": "Test exit functions"
        },
        {
          "id": "3",
          "name": "Test timeout functions"
        },
        {
          "id": "4",
          "name": "Test types match expected types of their default/original implementation"
        }
      ],
      "source": "import {\r\n    aggregateErrorFetchFunction,\r\n    badRequestFetchFunction,\r\n    brokenJSONFetchFunction,\r\n    doNotExitFunction,\r\n    fixedDateFunction,\r\n    fixedResponseFetchFunction,\r\n    graphQLIntrospectionDisabledFetchFunction,\r\n    graphQLInvalidBodyFetchFunction,\r\n    graphQLInvalidSchemaFetchFunction,\r\n    internalServerErrorFetchFunction,\r\n    noCallbackTimeoutFunction,\r\n    notFoundFetchFunction,\r\n    nowDateFunction,\r\n    testDateFunction,\r\n    testDateString,\r\n    timeoutFetchFunction,\r\n    unknownContentTypeFetchFunction,\r\n} from '@/index'\r\n// eslint-disable-next-line @typescript-eslint/no-duplicate-imports\r\nimport type {\r\n    DateFunction,\r\n    ExitFunction,\r\n    FetchFunction,\r\n    TimeoutFunction,\r\n} from '@/index'\r\nimport { expect, test } from 'vitest'\r\n\r\n/**\r\n * Example Logger class to test the date functions.\r\n * The DateFunction is passed as an optional function parameter to the log\r\n * and prepareLogMessage functions in order to be able to set a custom DateFunction if necessary.\r\n */\r\nclass Logger {\r\n    logEntries: string[] = []\r\n\r\n    /**\r\n     * Setting the default value to nowDateFunction will make it\r\n     * easier to call the function without the caller providing a DateFunction argument\r\n     */\r\n    log(message: string, dateFunction: DateFunction = nowDateFunction()): void {\r\n        const logEntry = this.prepareLogMessage(message, dateFunction)\r\n        this.logEntries.push(logEntry)\r\n        console.log(logEntry)\r\n    }\r\n\r\n    /**\r\n     * prepareLogMessage prepares the log message and returns it as a string.\r\n     * This will make it easier to test the output without having to spy on\r\n     * the console.log function.\r\n     */\r\n    prepareLogMessage(\r\n        message: string,\r\n        dateFunction: DateFunction = nowDateFunction(),\r\n    ): string {\r\n        return `${dateFunction().toISOString()} : ${message}`\r\n    }\r\n}\r\n\r\n/**\r\n * Example async function to test the fetch functions.\r\n * This function tries to fetch user data from a server and returns a string with the user data.\r\n * By providing an optional function parameter fetchFunction that is set to globalThis.fetch this\r\n * would try to fetch the user data from a server. In tests this function can be set to test\r\n * different scenarios like a successful fetch, a \"not found\" response or a timeout response.\r\n */\r\nasync function getUserById(\r\n    id: string,\r\n    fetchFunction: FetchFunction = globalThis.fetch,\r\n): Promise<string> {\r\n    try {\r\n        const userDataResponse = await fetchFunction(\r\n            `https://localhost:3000/users/${id}`,\r\n        )\r\n        if (!userDataResponse.ok) {\r\n            return `User was not found. Status is ${userDataResponse.status}`\r\n        }\r\n        return `User ${await userDataResponse.text()}`\r\n    } catch (error) {\r\n        return `Error: ${error}`\r\n    }\r\n}\r\n\r\n/**\r\n * Second example async function to test the fetch functions (see above)\r\n * This function tries to work with JSON data so these scenarios can be tested.\r\n */\r\nasync function getJSONMessage(\r\n    fetchFunction: FetchFunction = globalThis.fetch,\r\n): Promise<{ data: { message: string } }> {\r\n    try {\r\n        const messageResponse = await fetchFunction(\r\n            'https://localhost:3000/message/',\r\n        )\r\n        if (!messageResponse.ok) {\r\n            return { data: { message: 'Message error!' } }\r\n        }\r\n\r\n        if (\r\n            messageResponse.headers.get('Content-Type') !== 'application/json'\r\n        ) {\r\n            return {\r\n                data: {\r\n                    message: 'Error: Content-Type is not application/json',\r\n                },\r\n            }\r\n        }\r\n\r\n        const message = await messageResponse.json()\r\n        return message\r\n    } catch (error) {\r\n        return { data: { message: `Error: ${error}` } }\r\n    }\r\n}\r\n\r\ntest('Test date functions', () => {\r\n    const logger = new Logger()\r\n\r\n    // Test that the fixed date function returns the correct date\r\n    expect(\r\n        logger.prepareLogMessage(\r\n            'I am a log message!',\r\n            fixedDateFunction('2023-09-06T00:00:00Z'),\r\n        ),\r\n    ).toBe('2023-09-06T00:00:00.000Z : I am a log message!')\r\n\r\n    // Test that the testDateFunction returns the test date\r\n    expect(\r\n        logger.prepareLogMessage('I am a log message!', testDateFunction),\r\n    ).toBe(`${testDateString} : I am a log message!`)\r\n\r\n    // Test that calling prepareLogMessage without a dateFunction argument does not run into an error\r\n    expect(logger.prepareLogMessage('I am a log message!')).toContain(\r\n        'I am a log message!',\r\n    )\r\n})\r\n\r\ntest('Test fetch functions', async () => {\r\n    // Test that fixedResponseFetchFunction return the correct response\r\n    expect(\r\n        await getUserById(\r\n            '1',\r\n            fixedResponseFetchFunction('John Doe', { status: 200 }),\r\n        ),\r\n    ).toBe('User John Doe')\r\n\r\n    // Test that badRequestFetchFunction is handled properly\r\n    expect(await getUserById('1', badRequestFetchFunction)).toBe(\r\n        'User was not found. Status is 400',\r\n    )\r\n\r\n    // Test that notFoundFetchFunction is handled properly\r\n    expect(await getUserById('1', notFoundFetchFunction)).toBe(\r\n        'User was not found. Status is 404',\r\n    )\r\n\r\n    // Test that internalServerErrorFetchFunction is handled properly\r\n    expect(await getUserById('1', internalServerErrorFetchFunction)).toBe(\r\n        'User was not found. Status is 500',\r\n    )\r\n\r\n    // Test that timeoutFetchFunction is handled properly\r\n    expect(await getUserById('1', timeoutFetchFunction)).toBe(\r\n        'Error: Error: Connection failed ETIMEDOUT',\r\n    )\r\n\r\n    // Test that aggregateErrorFetchFunction is handled properly\r\n    expect(await getUserById('1', aggregateErrorFetchFunction)).toBe(\r\n        'User {\"errors\":[{\"message\":\"aaa The first error!, The second error!\", \"originalError\": {\"errors\": [{\"message\":\"The first error!\"}, {\"message\":\"The second error!\"}  ] }  }]}',\r\n    )\r\n\r\n    // Test that graphQLIntrospectionDisabledFetchFunction is handled properly\r\n    expect(\r\n        await getUserById('1', graphQLIntrospectionDisabledFetchFunction),\r\n    ).toBe(\r\n        'User {\"errors\": [ { \"message\": \"Introspection is disabled\"}],\"data\": null}',\r\n    )\r\n\r\n    // Test that graphQLInvalidSchemaFetchFunction is handled properly\r\n    expect(await getUserById('1', graphQLInvalidSchemaFetchFunction)).toBe(\r\n        'User {\"data\": {\"__schema\":\"NotAGraphQLSchema\", \"_service\": {\"sdl\":\"NotAGraphQLSchema\"}}}',\r\n    )\r\n\r\n    // Test that graphQLInvalidBodyFetchFunction is handled properly\r\n    expect(await getUserById('1', graphQLInvalidBodyFetchFunction)).toBe(\r\n        'User {\"message\": \"I am not GraphQL!\"}',\r\n    )\r\n\r\n    // Test that fixedResponseFetchFunction with a JSON response return the correct response\r\n    expect(\r\n        await getJSONMessage(\r\n            fixedResponseFetchFunction(\r\n                '{\"data\": {\"message\": \"Hello world!\"}}',\r\n                {\r\n                    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    status: 200,\r\n                },\r\n            ),\r\n        ),\r\n    ).toEqual({ data: { message: 'Hello world!' } })\r\n\r\n    // Test that brokenJSONFetchFunction is handled properly\r\n    const brokenJSONResponse = await getJSONMessage(brokenJSONFetchFunction)\r\n    expect(brokenJSONResponse.data.message).toContain('SyntaxError')\r\n\r\n    // Test that unknownContentTypeFetchFunction is handled properly\r\n    expect(await getJSONMessage(unknownContentTypeFetchFunction)).toEqual({\r\n        data: { message: 'Error: Content-Type is not application/json' },\r\n    })\r\n})\r\n\r\ntest('Test exit functions', () => {\r\n    // Test that doNotExitFunction does not exit and returns the correct error message\r\n    expect(() => doNotExitFunction(1)).toThrow(\r\n        'Exit function was called with code 1',\r\n    )\r\n})\r\n\r\ntest('Test timeout functions', () => {\r\n    const logger = new Logger()\r\n    // noCallbackTimeoutFunction should return a fixed timeout ID 1\r\n    expect(\r\n        noCallbackTimeoutFunction(\r\n            () => logger.log('This should not be executed!'),\r\n            1000,\r\n        ),\r\n    ).toBe(1)\r\n    // Log call in callback function should not be executed\r\n    expect(logger.logEntries.length).toBe(0)\r\n})\r\n\r\ntest('Test types match expected types of their default/original implementation', () => {\r\n    /*\r\n     * Note:\r\n     * While this test might still pass for type mismatches,\r\n     * the type check in \"check\" script will fail if the types do not match and cannot be casted\r\n     */\r\n    const defaultFetchFunction: FetchFunction = globalThis.fetch\r\n    expect(defaultFetchFunction).toBeDefined()\r\n    const defaultExitFunction: ExitFunction = process.exit\r\n    expect(defaultExitFunction).toBeDefined()\r\n    const defaultTimeoutFunction: TimeoutFunction = globalThis.setTimeout\r\n    expect(defaultTimeoutFunction).toBeDefined()\r\n})\r\n"
    }
  },
  "projectRoot": "C:\\ws_nodejs\\dreamit-funpara",
  "config": {
    "$schema": "./node_modules/@stryker-mutator/core/schema/stryker-schema.json",
    "_comment": "This config was generated using 'stryker init'. Please take a look at: https://stryker-mutator.io/docs/stryker-js/configuration/ for more information.",
    "packageManager": "npm",
    "reporters": [
      "html",
      "clear-text",
      "progress"
    ],
    "testRunner": "vitest",
    "testRunner_comment": "Take a look at https://stryker-mutator.io/docs/stryker-js/vitest-runner for information about the vitest plugin.",
    "coverageAnalysis": "perTest",
    "buildCommand": "npm run build",
    "ignorers": [
      "log-ignore"
    ],
    "plugins": [
      "@stryker-mutator/*",
      "@sgohlke/stryker-log-ignorer"
    ],
    "logignore": {
      "objectNames": [
        "logger"
      ]
    },
    "ignoreStatic": true,
    "incremental": true,
    "incrementalFile": "stryker-incremental.json",
    "allowConsoleColors": true,
    "checkers": [],
    "checkerNodeArgs": [],
    "commandRunner": {
      "command": "npm test"
    },
    "clearTextReporter": {
      "allowColor": true,
      "allowEmojis": false,
      "logTests": true,
      "maxTestsToLog": 3,
      "reportTests": true,
      "reportMutants": true,
      "reportScoreTable": true,
      "skipFull": false
    },
    "dashboard": {
      "baseUrl": "https://dashboard.stryker-mutator.io/api/reports",
      "reportType": "full"
    },
    "dryRunOnly": false,
    "eventReporter": {
      "baseDir": "reports/mutation/events"
    },
    "ignorePatterns": [],
    "force": false,
    "fileLogLevel": "off",
    "inPlace": false,
    "logLevel": "info",
    "maxConcurrentTestRunners": 9007199254740991,
    "maxTestRunnerReuse": 0,
    "mutate": [
      "{src,lib}/**/!(*.+(s|S)pec|*.+(t|T)est).+(cjs|mjs|js|ts|mts|cts|jsx|tsx|html|vue|svelte)",
      "!{src,lib}/**/__tests__/**/*.+(cjs|mjs|js|ts|mts|cts|jsx|tsx|html|vue|svelte)"
    ],
    "mutator": {
      "plugins": null,
      "excludedMutations": []
    },
    "appendPlugins": [],
    "htmlReporter": {
      "fileName": "reports/mutation/mutation.html"
    },
    "jsonReporter": {
      "fileName": "reports/mutation/mutation.json"
    },
    "disableTypeChecks": true,
    "symlinkNodeModules": true,
    "tempDirName": ".stryker-tmp",
    "cleanTempDir": true,
    "testRunnerNodeArgs": [],
    "thresholds": {
      "high": 80,
      "low": 60,
      "break": null
    },
    "timeoutFactor": 1.5,
    "timeoutMS": 5000,
    "dryRunTimeoutMinutes": 5,
    "tsconfigFile": "tsconfig.json",
    "warnings": true,
    "disableBail": false,
    "allowEmpty": false,
    "vitest": {}
  },
  "framework": {
    "name": "StrykerJS",
    "version": "9.0.1",
    "branding": {
      "homepageUrl": "https://stryker-mutator.io",
      "imageUrl": "data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"
    },
    "dependencies": {
      "typescript": "5.8.3"
    }
  }
}